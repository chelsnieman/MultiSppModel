table<-dbGetQuery(con,paste("SELECT * FROM", table)) #note that capitalization doesn't matter so LAKES=lakes
###alter column classes within tables
dateFix=c("dateSet", "dateSample", "dateRun" )
dateTimeFix=c("dateTimeSet", "dateTimeSample")
numericFix=c("benthicBacterialProductionVolume_ugC_L_h","benthicBacterialProductionArea_mgC_m2_h","incubationDuration_h","BacterialProduction_ugC_L_h","depthTop","depthBottom","bodyLength","headWidth","dryMass","chl","abs440","g440","DOC","TN_DOC","dietItemCount","dietItemBodyLength","dietItemHeadWidth","otherLength","dietItemRangeLower","dietItemRangeHigher","dryMass_bodylength","dryMass_headwidth","dryMass_other","totalDryMass","fishLength","fishWeight","mortality","removed","otolithSample","tissueSampled","dietSampled","gonadRemoved","leftEyeRemoved","photo","gonadWeight","gonadSqueze","annulusNumber","paramValue","interpretationNumber","effort","CH4PeakArea","CO2PeakArea","CH4ppm","CO2ppm","CH4_uM","CO2_uM","sampleWt","d13C","d15N","d2H","d18O","percentC","percentN","percentH","surfaceArea","maxDepth","lat","long","temp","DOmgL","DOsat","SpC","pH","ORP","PAR","parameterValue","lakeLevel_m","wellLevel_m","wellLevelCorrected_m","hydraulicHead_m","wellHeightAboveGround_m","waterTable_m","filterVol","sampleAmount","POC","PON","benthicRespiration_mgC_m2_h","benthicNPP_mgC_m2_h","benthicGPP_mgC_m2_h","ppb","rhodReleaseVolume","wetMass","ashedMass","percentOrganic","waterHeight","waterHeight_m","tPOCdepGreater35_mgC_m2_d","tPOCdepLess35_mgC_m2_d","count","abundance_num_m3","biomass_gDryMass_m3","slope","intercept","length","width","mass","eggs","production","prodSD","seasonalSD","production_m3","prodSD_m3","seasonalSD_m3","production_eggRatio","wtEmpty","wtFull","wtSubsample")
integerFix=c("flag")
factorFix=c("replicate")
for(i in which(colnames(table) %in% dateFix)) {
table[,i] <- as.Date(table[,i],tz="America/Chicago")
}
for(i in which(colnames(table) %in% dateTimeFix)) {
table[,i] <- as.POSIXct(table[,i],tz="America/Chicago")
}
for(i in which(colnames(table) %in% numericFix)) {
table[,i] <- as.numeric(table[,i])
}
for(i in which(colnames(table) %in% integerFix)) {
table[,i] <- as.integer(table[,i])
}
for(i in which(colnames(table) %in% factorFix)) {
table[,i] <- as.factor(table[,i])
}
#summarize table
summary=list()
for(i in 1:length(cols)){
print(paste(cols[i]," - ",typeof(table[,cols[i]]),":",sep=""),quote=FALSE)
print(sort(unique(table[,cols[i]])),quote=FALSE)
}
dbDisconnect(con)
}
# Importing database tables
dbTable<-function(table,lakeID=c(),depthClass=c(),fpath=dbdir,dbname=db){
#set file path to the location of the database (defaults to my database location)
table=as.character(table)
drv=SQLite() #create driver object
con=dbConnect(drv,dbname=file.path(fpath,dbname)) #open database connection
#query an entire table
table<-dbGetQuery(con,paste("SELECT * FROM", table)) #note that capitalization doesn't matter so LAKES=lakes
if(!is.null(lakeID)){
table<-table[table$lakeID%in%lakeID,]
}
if(!is.null(depthClass)){
table<-table[table$depthClass%in%depthClass,]
}
###alter column classes within tables
dateFix=c("dateSet", "dateSample", "dateRun" )
dateTimeFix=c("dateTimeSet", "dateTimeSample")
numericFix=c("benthicBacterialProductionVolume_ugC_L_h","benthicBacterialProductionArea_mgC_m2_h","incubationDuration_h","BacterialProduction_ugC_L_h","depthTop","depthBottom","bodyLength","headWidth","dryMass","chl","abs440","g440","DOC","TN_DOC","dietItemCount","dietItemBodyLength","dietItemHeadWidth","otherLength","dietItemRangeLower","dietItemRangeHigher","dryMass_bodylength","dryMass_headwidth","dryMass_other","totalDryMass","fishLength","fishWeight","mortality","removed","otolithSample","tissueSampled","dietSampled","gonadRemoved","leftEyeRemoved","photo","gonadWeight","gonadSqueze","annulusNumber","paramValue","interpretationNumber","effort","CH4PeakArea","CO2PeakArea","CH4ppm","CO2ppm","CH4_uM","CO2_uM","sampleWt","d13C","d15N","d2H","d18O","percentC","percentN","percentH","surfaceArea","maxDepth","lat","long","temp","DOmgL","DOsat","SpC","pH","ORP","PAR","parameterValue","lakeLevel_m","wellLevel_m","wellLevelCorrected_m","hydraulicHead_m","wellHeightAboveGround_m","waterTable_m","filterVol","sampleAmount","POC","PON","benthicRespiration_mgC_m2_h","benthicNPP_mgC_m2_h","benthicGPP_mgC_m2_h","ppb","rhodReleaseVolume","wetMass","ashedMass","percentOrganic","waterHeight","waterHeight_m","tPOCdepGreater35_mgC_m2_d","tPOCdepLess35_mgC_m2_d","count","abundance_num_m3","biomass_gDryMass_m3","slope","intercept","length","width","mass","eggs","production","prodSD","seasonalSD","production_m3","prodSD_m3","seasonalSD_m3","production_eggRatio","wtEmpty","wtFull","wtSubsample")
integerFix=c("flag")
factorFix=c("replicate")
for(i in which(colnames(table) %in% dateFix)) {
table[,i] <- as.Date(table[,i],tz="America/Chicago")
}
for(i in which(colnames(table) %in% dateTimeFix)) {
table[,i] <- as.POSIXct(table[,i],tz="America/Chicago")
}
for(i in which(colnames(table) %in% numericFix)) {
table[,i] <- as.numeric(table[,i])
}
for(i in which(colnames(table) %in% integerFix)) {
table[,i] <- as.integer(table[,i])
}
for(i in which(colnames(table) %in% factorFix)) {
table[,i] <- as.factor(table[,i])
}
return(table)
}
setwd("C:/Users/jones/Downloads")
?read.csv
df=read.table("remaning_dup_fishIDs.txt", header = T,sep = ',',stringsAsFactors = F)
df=read.table("remaining_dup_fishIDs.txt", header = T,sep = ',',stringsAsFactors = F)
View(df)
getwd()
setwd("C:/Users/jones/BoxSync/NDstuff/Dissertation/2/scripts_data/")
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec")
nabYr[18,5]=0.15; nabYr[23,5]=0.083; nabYr[20:21,5]=0.13 #interpolating the few years without data
nabYr=full_join(nabYr,nabFyke)%>%
full_join(nabAN)
library(BayesianTools)
library(dplyr)
rm(list=ls())
#### OBSERVED DATA ####
nab=read.csv("nabData_modelFormat.csv", stringsAsFactors = F)
#plot(nab$year, nab$lengths_cm)
#getting sample counts for obs model input
nabFyke=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObs=n(), sumSQL=sum(length_cm^2))
yearsAN=data.frame(year=1956:2015)
nabAN=nab%>%
filter(method==1 | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObsAN=n(), sumSQLAN=sum(length_cm^2))%>%
full_join(yearsAN)%>%
arrange(year)
#setting the few mising years draws to 0
nabFyke$numObs[c(18,20,21,23)]=0
#trimming individual fish data to year, length, age columns I care about for likelihood
i.obs=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
select(year, length_cm, age)
#exploitation rates & PEs
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec")
nabYr[18,5]=0.15; nabYr[23,5]=0.083; nabYr[20:21,5]=0.13 #interpolating the few years without data
nabYr=full_join(nabYr,nabFyke)%>%
full_join(nabAN)
nabYr$numObsAN[is.na(nabYr$numObsAN)==T]=0
nabYr=nabYr[nabYr$year!=2016,]
colnames(nabYr)
plot(nabYr$year, nabYr$pe, xlab = "Year", ylab = "PE")
plot(nabYr$year, nabYr$pe, xlab = "Year", ylab = "PE", pch=16)
par(mar=c(5,4,4,4))
plot(nabYr$year, nabYr$pe, xlab = "Year", ylab = "PE", pch=16)
par(new=T)
plot(nabYr$year, nabYr$sumSQL, pch=16, col="red", axes = F, xlab = "", ylab = "")
axis(side = 4)
mtext("sum sq length", side = 4)
mtext("sum sq length", side = 4, line = 3)
mtext("sum sq length", side = 4, line = 2)
plot(nabYr$pe, nabYr$sumSQL, xlab = "PE", ylab = "sum sq length")
plot(nabYr$pe, nabYr$sumSQL, xlab = "PE", ylab = "sum sq length", pch=16)
par(mar=c(5,4,4,4))
plot(nabYr$year, nabYr$pe, xlab = "Year", ylab = "PE", pch=16)
par(new=T)
plot(nabYr$year, nabYr$sumSQL, pch=16, col="red", axes = F, xlab = "", ylab = "")
axis(side = 4)
mtext("sum sq length", side = 4, line = 2)
par(mar=c(5,4,4,4))
plot(nabYr$year, nabYr$pe, xlab = "Year", ylab = "PE", pch=16)
par(new=T)
plot(nabYr$year, nabYr$sumSQL, pch=16, col="red", axes = F, xlab = "", ylab = "")
axis(side = 4)
mtext("sum sq length", side = 4, line = 2)
legend("topleft", legend = c("PE","sumsqL"), pch=16, col = c("black","red"))
par(new=T)
plot(nabYr$pe, nabYr$sumSQL, xlab = "PE", ylab = "sum sq length", pch=16)
par(new=F)
plot(nabYr$pe, nabYr$sumSQL, xlab = "PE", ylab = "sum sq length", pch=16)
dev.off()
plot(nabYr$pe, nabYr$sumSQL, xlab = "PE", ylab = "sum sq length", pch=16)
View(nabYr)
nabYr$peSource=c(rep("hoff&serns",26), rep(NA,5),rep("newNAB",28))
nabYr$peSource=c(rep("hoff&serns",26), rep(NA,5),rep("newNAB",29))
p=ggplot(nabYr)
library(ggplot2)
p=ggplot(nabYr)
p=ggplot(nabYr)+theme_classic()
p+geom_point(aes(x=PE,y=sumSQL,fill=peSource))
p+geom_point(aes(x=pe,y=sumSQL,fill=peSource))
p+geom_point(aes(x=pe,y=sumSQL),fill=peSource)
p+geom_point(aes(x=pe,y=sumSQL),color=peSource)
colnames(nabYr)
p+geom_point(aes(x=pe,y=sumSQL),fill=peSource)
p=ggplot(nabYr)+theme_classic()
p+geom_point(aes(x=pe,y=sumSQL),fill=peSource)
p+geom_point(aes(x=pe,y=sumSQL,fill=peSource))
p+geom_point(aes(x=pe,y=sumSQL,fill=peSource),color=c("black","red","blue"))
p+geom_point(aes(x=pe,y=sumSQL,fill=factor(peSource)))
p+geom_point(aes(x=pe,y=sumSQL,color=factor(peSource)))
p+geom_point(aes(x=pe,y=sumSQL,color=factor(peSource)))+theme(legend.position = "bottom")
install.packages('rmarkdown')
library('rmarkdown')
library(BayesianTools)
library(dplyr)
rm(list=ls())
#### OBSERVED DATA ####
nab=read.csv("nabData_modelFormat.csv", stringsAsFactors = F)
#plot(nab$year, nab$lengths_cm)
#getting sample counts for obs model input
nabFyke=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObs=n(), sumSQL=sum(length_cm^2))
yearsAN=data.frame(year=1956:2015)
nabAN=nab%>%
filter(method==1 | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObsAN=n(), sumSQLAN=sum(length_cm^2))%>%
full_join(yearsAN)%>%
arrange(year)
#setting the few mising years draws to 0
nabFyke$numObs[c(18,20,21,23)]=0
#trimming individual fish data to year, length, age columns I care about for likelihood
i.obs=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
select(year, length_cm, age)
#exploitation rates & PEs
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec")
?dnorm
View(nabYr)
nabYr[18,5]=0.15; nabYr[23,5]=0.083; nabYr[20:21,5]=0.13 #interpolating the few years without data
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec","pe_sd")
rm(list=ls())
#### OBSERVED DATA ####
nab=read.csv("nabData_modelFormat.csv", stringsAsFactors = F)
#plot(nab$year, nab$lengths_cm)
#getting sample counts for obs model input
nabFyke=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObs=n(), sumSQL=sum(length_cm^2))
yearsAN=data.frame(year=1956:2015)
nabAN=nab%>%
filter(method==1 | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObsAN=n(), sumSQLAN=sum(length_cm^2))%>%
full_join(yearsAN)%>%
arrange(year)
#setting the few mising years draws to 0
nabFyke$numObs[c(18,20,21,23)]=0
#trimming individual fish data to year, length, age columns I care about for likelihood
i.obs=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
select(year, length_cm, age)
#exploitation rates & PEs
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec","pe_sd")
nabYr[18,5]=0.15; nabYr[23,5]=0.083; nabYr[20:21,5]=0.13 #interpolating the few years without data
nabYr=full_join(nabYr,nabFyke)%>%
full_join(nabAN)
nabYr$numObsAN[is.na(nabYr$numObsAN)==T]=0
nabYr=nabYr[nabYr$year!=2016,]
colnames(Yr)
colnames(nabYr)
rm(list=ls())
#### OBSERVED DATA ####
nab=read.csv("nabData_modelFormat.csv", stringsAsFactors = F)
#plot(nab$year, nab$lengths_cm)
#getting sample counts for obs model input
nabFyke=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObs=n(), sumSQL=sum(length_cm^2))
yearsAN=data.frame(year=1956:2015)
nabAN=nab%>%
filter(method==1 | is.na(method)==T)%>%
group_by(year)%>%
summarize(numObsAN=n(), sumSQLAN=sum(length_cm^2))%>%
full_join(yearsAN)%>%
arrange(year)
#setting the few mising years draws to 0
nabFyke$numObs[c(18,20,21,23)]=0
#trimming individual fish data to year, length, age columns I care about for likelihood
i.obs=nab%>%
filter(method==2 | method=="fyke" | is.na(method)==T)%>%
select(year, length_cm, age)
#exploitation rates & PEs
nabYr=read.csv("fullNAB_PE.csv", header = T, stringsAsFactors = F)
colnames(nabYr)=c("year", "pe","L.CI","U.CI","urec","pe_sd")
nabYr[18,5]=0.15; nabYr[23,5]=0.083; nabYr[20:21,5]=0.13 #interpolating the few years without data
nabYr=full_join(nabYr,nabFyke)%>%
full_join(nabAN)
nabYr$numObsAN[is.na(nabYr$numObsAN)==T]=0
nabYr=nabYr[nabYr$year!=2016,]
#burn in equilibrium abundances for escanaba
burnStart=c(1157,58,15,5,4,rep(3,22),2,1,1)
#### LIKELIHOOD & STARTING VALUES ####
#LOADING LIKELIHOOD FUNCTION
#source('mskLikelihood.R')
source('newMSKLikelihood.R')
# STARTING VALUES
#parameters to be estimated
parameters=c(d.d=7, canR=10, stdAbund=log(25), stdVonB=log(10), LogstdSQL=log(1.07e5), LogstdSQLAN=log(2.6e4))
#our observations of "real life"- need to be put into a vector for dnorm()
dataIN=list(abundObs=nabYr[,c(1:4,6)], fishobs=i.obs, sqL=nabYr[,c(1,8)], sqLAN=nabYr[,c(1,10)])
#initial observations to start the model
start=list(popSize=burnStart)
knitr::opts_chunk$set(echo = TRUE)
packages <- c("citr","bibtex","tidyverse","knitr","tinytex")
setwd("C:/Users/jones/BoxSync/NDstuff/Dissertation/4/MultiSppModel")
#some other packages and code to be used throughout the document
# Colin setting his working directory setwd("C:/Users/jones/BoxSync/NDstuff/Dissertation/4/MultiSppModel")
library(deSolve)
library(ggpubr)
source("q2Func.R")
knitr::opts_chunk$set(echo = TRUE)
packages <- c("citr","bibtex","tidyverse","knitr","tinytex")
#some other packages and code to be used throughout the document
# Colin setting his working directory setwd("C:/Users/jones/BoxSync/NDstuff/Dissertation/4/MultiSppModel")
library(deSolve)
library(ggpubr)
source("q2Func.R")
#not sure exactly where we want this, in the simulation space or right in the results
#### OUTCOMES WITH HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
df=expand.grid(X=qEs,Y=sto)
df$A1=numeric(nrow(df))
df$A2=numeric(nrow(df))
df$J1=numeric(nrow(df))
df$J2=numeric(nrow(df))
for(i in 1:nrow(df)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(df$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(df$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0.5,cJ1J2=0.003,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0.003,cJ2J1=0.003,v2=1,f2=3)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
df$A1[i]=sim[nrow(sim)-1,2]
df$A2[i]=sim[nrow(sim)-1,3]
df$J1[i]=sim[nrow(sim)-1,4]
df$J2[i]=sim[nrow(sim)-1,5]
}
#not sure exactly where we want this, in the simulation space or right in the results
#these get reused for both plots below
h1Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
h2Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
#### OUTCOMES WITH HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
df=expand.grid(X=qEs,Y=sto)
df$A1=numeric(nrow(df))
df$A2=numeric(nrow(df))
df$J1=numeric(nrow(df))
df$J2=numeric(nrow(df))
for(i in 1:nrow(df)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(df$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(df$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0.5,cJ1J2=0.003,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0.003,cJ2J1=0.003,v2=1,f2=3)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
df$A1[i]=sim[nrow(sim)-1,2]
df$A2[i]=sim[nrow(sim)-1,3]
df$J1[i]=sim[nrow(sim)-1,4]
df$J2[i]=sim[nrow(sim)-1,5]
}
vz=ggplot(data = df)+theme_classic()
a=vz+geom_tile(aes(x=df$X, y=df$Y, fill=df$A1))+scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked fish", title = "Hysteresis Present")
#### OUTCOMES WITHOUT HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
dfwo=expand.grid(X=qEs,Y=sto)
dfwo$A1=numeric(nrow(dfwo))
dfwo$A2=numeric(nrow(dfwo))
dfwo$J1=numeric(nrow(dfwo))
dfwo$J2=numeric(nrow(dfwo))
for(i in 1:nrow(dfwo)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(dfwo$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(dfwo$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0,cJ1J2=0,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0,cJ2J1=0,v2=1,f2=2)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
dfwo$A1[i]=sim[nrow(sim)-1,2]
dfwo$A2[i]=sim[nrow(sim)-1,3]
dfwo$J1[i]=sim[nrow(sim)-1,4]
dfwo$J2[i]=sim[nrow(sim)-1,5]
}
vzwo=ggplot(data = dfwo)+theme_classic()
b=vzwo+geom_tile(aes(x=dfwo$X, y=dfwo$Y, fill=dfwo$A1))+
scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked fish", title = "No Hysteresis Present")
#comparing with and without hysteresis plots together
ggarrange(a,b,labels = c("A","B"), nrow = 1,ncol = 2)
vz=ggplot(data = df)+theme_classic()
a=vz+geom_tile(aes(x=df$X, y=df$Y, fill=df$A1))+scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked fish", title = "Hysteresis Present")+
guides(fill="none")
vzwo=ggplot(data = dfwo)+theme_classic()
b=vzwo+geom_tile(aes(x=dfwo$X, y=dfwo$Y, fill=dfwo$A1))+
scale_fill_gradient(low ="blue", high = "yellow", name="A1 Abund")+
labs(x="Harvest Rate", y="", title = "No Hysteresis Present")
#comparing with and without hysteresis plots together
ggarrange(a,b,labels = c("A","B"), nrow = 1,ncol = 2)
#not sure exactly where we want this, in the simulation space or right in the results
#these get reused for both plots below
h1Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
h2Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
#### OUTCOMES WITH HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
df=expand.grid(X=qEs,Y=sto)
df$A1=numeric(nrow(df))
df$A2=numeric(nrow(df))
df$J1=numeric(nrow(df))
df$J2=numeric(nrow(df))
for(i in 1:nrow(df)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(df$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(df$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0.5,cJ1J2=0.003,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0.003,cJ2J1=0.003,v2=1,f2=3)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
df$A1[i]=sim[nrow(sim)-1,2]
df$A2[i]=sim[nrow(sim)-1,3]
df$J1[i]=sim[nrow(sim)-1,4]
df$J2[i]=sim[nrow(sim)-1,5]
}
vz=ggplot(data = df)+theme_classic()
a=vz+geom_tile(aes(x=df$X, y=df$Y, fill=df$A1))+scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked Fish per Year", title = "Hysteresis Present")+
guides(fill="none")
#### OUTCOMES WITHOUT HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
dfwo=expand.grid(X=qEs,Y=sto)
dfwo$A1=numeric(nrow(dfwo))
dfwo$A2=numeric(nrow(dfwo))
dfwo$J1=numeric(nrow(dfwo))
dfwo$J2=numeric(nrow(dfwo))
for(i in 1:nrow(dfwo)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(dfwo$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(dfwo$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0,cJ1J2=0,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0,cJ2J1=0,v2=1,f2=2)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
dfwo$A1[i]=sim[nrow(sim)-1,2]
dfwo$A2[i]=sim[nrow(sim)-1,3]
dfwo$J1[i]=sim[nrow(sim)-1,4]
dfwo$J2[i]=sim[nrow(sim)-1,5]
}
vzwo=ggplot(data = dfwo)+theme_classic()
b=vzwo+geom_tile(aes(x=dfwo$X, y=dfwo$Y, fill=dfwo$A1))+
scale_fill_gradient(low ="blue", high = "yellow", name="A1 Abund")+
labs(x="Harvest Rate", y="", title = "No Hysteresis Present")
#comparing with and without hysteresis plots together
ggarrange(a,b,labels = c("A","B"), nrow = 1,ncol = 2)
#this plot is a start at least, the point here is that when the species interact (hysteresis present) low levels of stocking at any harvest rate aren't enough to keep the system in a state where A1 dominates. (right now I'm using A1 abundance at my way of telling who dominates but it's not quite right I don't think. It'd be easy enough to pull different info out of the model runs if we wanted.)
vzwo=ggplot(data = dfwo)+theme_classic()
b=vzwo+geom_tile(aes(x=dfwo$X, y=dfwo$Y, fill=dfwo$A1))+
scale_fill_gradient(low ="blue", high = "yellow", name="A1 Abund")+
labs(x="Harvest Rate", y="", title = "No Hysteresis Present")
#comparing with and without hysteresis plots together
ggarrange(a,b,labels = c("A","B"), nrow = 1,ncol = 2)
vz=ggplot(data = df)+theme_classic()
a=vz+geom_tile(aes(x=df$X, y=df$Y, fill=df$A1))+scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked Fish per Year", title = "Hysteresis Present")+
guides(fill="none")
#not sure exactly where we want this, in the simulation space or right in the results
#these get reused for both plots below
h1Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
h2Fun=approxfun(x=tstep,y=rep(8,length(tstep)))
#### OUTCOMES WITH HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
df=expand.grid(X=qEs,Y=sto)
df$A1=numeric(nrow(df))
df$A2=numeric(nrow(df))
df$J1=numeric(nrow(df))
df$J2=numeric(nrow(df))
for(i in 1:nrow(df)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(df$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(df$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0.5,cJ1J2=0.003,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0.003,cJ2J1=0.003,v2=1,f2=3)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
df$A1[i]=sim[nrow(sim)-1,2]
df$A2[i]=sim[nrow(sim)-1,3]
df$J1[i]=sim[nrow(sim)-1,4]
df$J2[i]=sim[nrow(sim)-1,5]
}
vz=ggplot(data = df)+theme_classic()
a=vz+geom_tile(aes(x=df$X, y=df$Y, fill=df$A1))+scale_fill_gradient(low ="blue", high = "yellow", name="")+
labs(x="Harvest Rate", y="Stocked Fish per Year", title = "Hysteresis Present")+
guides(fill="none")
#### OUTCOMES WITHOUT HYSTERESIS ####
qEs=seq(0,8,length.out = 15)
sto=seq(0,200, length.out = 15)
dfwo=expand.grid(X=qEs,Y=sto)
dfwo$A1=numeric(nrow(dfwo))
dfwo$A2=numeric(nrow(dfwo))
dfwo$J1=numeric(nrow(dfwo))
dfwo$J2=numeric(nrow(dfwo))
for(i in 1:nrow(dfwo)){
tstep=1:300
qE1Fun=approxfun(x=tstep,y=rep(dfwo$X[i], length(tstep)))
qE2Fun=approxfun(x=tstep,y=rep(0, length(tstep)))
st1Fun=approxfun(x=tstep,y=rep(dfwo$Y[i],length(tstep)))
st2Fun=approxfun(x=tstep,y=rep(0,length(tstep)))
p=c(s1=0.1,cJ1A1=0.002,cJ1A2=0,cJ1J2=0,v1=1,f1=2,
s2=0.1,cJ2A2=0.002,cJ2A1=0,cJ2J1=0,v2=1,f2=2)
y0=c(10,10,0,0)
sim=ode(y=y0,times=tstep,func=simBiggsQ2,parms=p)
dfwo$A1[i]=sim[nrow(sim)-1,2]
dfwo$A2[i]=sim[nrow(sim)-1,3]
dfwo$J1[i]=sim[nrow(sim)-1,4]
dfwo$J2[i]=sim[nrow(sim)-1,5]
}
vzwo=ggplot(data = dfwo)+theme_classic()
b=vzwo+geom_tile(aes(x=dfwo$X, y=dfwo$Y, fill=dfwo$A1))+
scale_fill_gradient(low ="blue", high = "yellow", name="A1 Abund")+
labs(x="Harvest Rate", y="", title = "No Hysteresis Present")
#comparing with and without hysteresis plots together
ggarrange(a,b,labels = c("A","B"), nrow = 1,ncol = 2)
#this plot is a start at least, the point here is that when the species interact (hysteresis present) low levels of stocking at any harvest rate aren't enough to keep the system in a state where A1 dominates. (right now I'm using A1 abundance at my way of telling who dominates but it's not quite right I don't think. It'd be easy enough to pull different info out of the model runs if we wanted.)
